"""
Advanced HACCKernels - Tree and Particle-Mesh Methods
Extended kernels implementing TreePM and advanced force calculation methods

This module implements more sophisticated force calculation methods used in HACC:
- Barnes-Hut tree algorithm for long-range forces
- Particle-Mesh (PM) methods for very long-range interactions  
- TreePM hybrid approach
- Fast Fourier Transform-based force calculation
- Multipole expansion methods

These methods reduce computational complexity from O(NÂ²) to O(N log N) or O(N)
"""

from algorithm import parallelize
from algorithm import vectorize
from memory import memset_zero, memcpy
from math import sqrt, rsqrt, pow, sin, cos, pi, log2
from random import rand
from time import now
from collections import Dict

# Advanced SIMD configuration for complex operations
alias SIMD_WIDTH_ADVANCED = 16
alias COMPLEX_TYPE = DType.float32
alias TREE_THETA = 0.5  # Barnes-Hut opening angle
alias MAX_TREE_DEPTH = 20

@value
struct Vector3D:
    """3D vector for positions and forces"""
    var x: Float32
    var y: Float32  
    var z: Float32
    
    fn __init__(inout self, x: Float32 = 0, y: Float32 = 0, z: Float32 = 0):
        self.x = x
        self.y = y
        self.z = z
    
    fn magnitude_squared(self) -> Float32:
        return self.x * self.x + self.y * self.y + self.z * self.z
    
    fn magnitude(self) -> Float32:
        return sqrt(self.magnitude_squared())
    
    fn normalize(inout self):
        let mag = self.magnitude()
        if mag > 1e-10:
            self.x /= mag
            self.y /= mag
            self.z /= mag

@value
struct BoundingBox:
    """3D bounding box for spatial decomposition"""
    var min_x: Float32
    var min_y: Float32
    var min_z: Float32
    var max_x: Float32
    var max_y: Float32
    var max_z: Float32
    
    fn __init__(inout self):
        self.min_x = 1e30
        self.min_y = 1e30
        self.min_z = 1e30
        self.max_x = -1e30
        self.max_y = -1e30
        self.max_z = -1e30
    
    fn expand(inout self, point: Vector3D):
        """Expand bounding box to include point"""
        self.min_x = min(self.min_x, point.x)
        self.min_y = min(self.min_y, point.y)
        self.min_z = min(self.min_z, point.z)
        self.max_x = max(self.max_x, point.x)
        self.max_y = max(self.max_y, point.y)
        self.max_z = max(self.max_z, point.z)
    
    fn center(self) -> Vector3D:
        return Vector3D(
            (self.min_x + self.max_x) / 2,
            (self.min_y + self.max_y) / 2,
            (self.min_z + self.max_z) / 2
        )
    
    fn size(self) -> Float32:
        let dx = self.max_x - self.min_x
        let dy = self.max_y - self.min_y
        let dz = self.max_z - self.min_z
        return max(dx, max(dy, dz))

struct TreeNode:
    """Octree node for Barnes-Hut algorithm"""
    var center_of_mass: Vector3D
    var total_mass: Float32
    var bounding_box: BoundingBox
    var is_leaf: Bool
    var particle_indices: DynamicVector[Int]
    var children: DynamicVector[Int]  # Indices to child nodes
    var depth: Int
    
    fn __init__(inout self):
        self.center_of_mass = Vector3D()
        self.total_mass = 0.0
        self.bounding_box = BoundingBox()
        self.is_leaf = True
        self.particle_indices = DynamicVector[Int]()
        self.children = DynamicVector[Int]()
        self.depth = 0

struct BarnesHutTree:
    """Barnes-Hut octree for efficient force calculation"""
    var nodes: DynamicVector[TreeNode]
    var root_index: Int
    var max_particles_per_leaf: Int
    var theta: Float32  # Opening angle criterion
    
    fn __init__(inout self, theta: Float32 = TREE_THETA):
        self.nodes = DynamicVector[TreeNode]()
        self.root_index = -1
        self.max_particles_per_leaf = 1
        self.theta = theta
    
    fn build_tree(inout self, inout particles: DynamicVector[Particle]):
        """Build octree from particle positions"""
        self.nodes.clear()
        
        if len(particles) == 0:
            return
        
        # Create root node
        var root = TreeNode()
        root.depth = 0
        
        # Calculate bounding box of all particles
        for i in range(len(particles)):
            let pos = Vector3D(
                particles[i].x.cast[DType.float32](),
                particles[i].y.cast[DType.float32](),
                particles[i].z.cast[DType.float32]()
            )
            root.bounding_box.expand(pos)
            root.particle_indices.push_back(i)
        
        self.nodes.push_back(root)
        self.root_index = 0
        
        # Recursively subdivide
        self._subdivide(0, particles)
        
        # Calculate centers of mass
        self._calculate_center_of_mass(0, particles)
    
    fn _subdivide(inout self, node_index: Int, inout particles: DynamicVector[Particle]):
        """Recursively subdivide octree node"""
        if node_index >= len(self.nodes):
            return
            
        var node = self.nodes[node_index]
        
        # Stop subdivision if leaf criteria met
        if len(node.particle_indices) <= self.max_particles_per_leaf or node.depth >= MAX_TREE_DEPTH:
            node.is_leaf = True
            self.nodes[node_index] = node
            return
        
        # Create 8 children for octree
        let center = node.bounding_box.center()
        var child_particles: DynamicVector[DynamicVector[Int]] = DynamicVector[DynamicVector[Int]]()
        
        # Initialize 8 child particle lists
        for i in range(8):
            child_particles.push_back(DynamicVector[Int]())
        
        # Distribute particles to children based on position relative to center
        for i in range(len(node.particle_indices)):
            let particle_idx = node.particle_indices[i]
            let pos = Vector3D(
                particles[particle_idx].x.cast[DType.float32](),
                particles[particle_idx].y.cast[DType.float32](),
                particles[particle_idx].z.cast[DType.float32]()
            )
            
            let child_idx = self._get_octant(pos, center)
            child_particles[child_idx].push_back(particle_idx)
        
        # Create child nodes
        node.is_leaf = False
        node.children.clear()
        
        for octant in range(8):
            if len(child_particles[octant]) > 0:
                var child = TreeNode()
                child.depth = node.depth + 1
                child.particle_indices = child_particles[octant]
                
                # Calculate child bounding box
                self._calculate_child_bbox(child.bounding_box, node.bounding_box, octant)
                
                let child_index = len(self.nodes)
                self.nodes.push_back(child)
                node.children.push_back(child_index)
                
                # Recursively subdivide child
                self._subdivide(child_index, particles)
        
        self.nodes[node_index] = node
    
    fn _get_octant(self, pos: Vector3D, center: Vector3D) -> Int:
        """Determine which octant a position belongs to"""
        var octant = 0
        if pos.x >= center.x:
            octant += 1
        if pos.y >= center.y:
            octant += 2  
        if pos.z >= center.z:
            octant += 4
        return octant
    
    fn _calculate_child_bbox(self, inout child_bbox: BoundingBox, parent_bbox: BoundingBox, octant: Int):
        """Calculate bounding box for child node"""
        let center = parent_bbox.center()
        
        child_bbox.min_x = parent_bbox.min_x if octant & 1 == 0 else center.x
        child_bbox.max_x = center.x if octant & 1 == 0 else parent_bbox.max_x
        
        child_bbox.min_y = parent_bbox.min_y if octant & 2 == 0 else center.y
        child_bbox.max_y = center.y if octant & 2 == 0 else parent_bbox.max_y
        
        child_bbox.min_z = parent_bbox.min_z if octant & 4 == 0 else center.z
        child_bbox.max_z = center.z if octant & 4 == 0 else parent_bbox.max_z
    
    fn _calculate_center_of_mass(inout self, node_index: Int, particles: DynamicVector[Particle]):
        """Calculate center of mass for tree node"""
        if node_index >= len(self.nodes):
            return
            
        var node = self.nodes[node_index]
        
        if node.is_leaf:
            # Calculate center of mass from particles
            var total_mass: Float32 = 0.0
            var weighted_pos = Vector3D()
            
            for i in range(len(node.particle_indices)):
                let particle_idx = node.particle_indices[i]
                let mass = particles[particle_idx].mass.cast[DType.float32]()
                
                weighted_pos.x += mass * particles[particle_idx].x.cast[DType.float32]()
                weighted_pos.y += mass * particles[particle_idx].y.cast[DType.float32]()
                weighted_pos.z += mass * particles[particle_idx].z.cast[DType.float32]()
                total_mass += mass
            
            if total_mass > 0:
                node.center_of_mass.x = weighted_pos.x / total_mass
                node.center_of_mass.y = weighted_pos.y / total_mass
                node.center_of_mass.z = weighted_pos.z / total_mass
            
            node.total_mass = total_mass
        else:
            # Calculate center of mass from children
            var total_mass: Float32 = 0.0
            var weighted_pos = Vector3D()
            
            for i in range(len(node.children)):
                let child_index = node.children[i]
                self._calculate_center_of_mass(child_index, particles)
                
                let child_node = self.nodes[child_index]
                let child_mass = child_node.total_mass
                
                weighted_pos.x += child_mass * child_node.center_of_mass.x
                weighted_pos.y += child_mass * child_node.center_of_mass.y
                weighted_pos.z += child_mass * child_node.center_of_mass.z
                total_mass += child_mass
            
            if total_mass > 0:
                node.center_of_mass.x = weighted_pos.x / total_mass
                node.center_of_mass.y = weighted_pos.y / total_mass
                node.center_of_mass.z = weighted_pos.z / total_mass
            
            node.total_mass = total_mass
        
        self.nodes[node_index] = node
    
    fn compute_force_on_particle(self, target_pos: Vector3D, target_mass: Float32, params: HACCParameters) -> Vector3D:
        """Compute gravitational force on target particle using Barnes-Hut approximation"""
        if self.root_index < 0:
            return Vector3D()
        
        return self._compute_force_recursive(self.root_index, target_pos, target_mass, params)
    
    fn _compute_force_recursive(self, node_index: Int, target_pos: Vector3D, target_mass: Float32, params: HACCParameters) -> Vector3D:
        """Recursively compute force using Barnes-Hut criterion"""
        if node_index >= len(self.nodes):
            return Vector3D()
            
        let node = self.nodes[node_index]
        
        # Calculate distance to center of mass
        let dx = node.center_of_mass.x - target_pos.x
        let dy = node.center_of_mass.y - target_pos.y
        let dz = node.center_of_mass.z - target_pos.z
        
        let r_sq = dx*dx + dy*dy + dz*dz + params.softening*params.softening
        let r = sqrt(r_sq)
        
        # Barnes-Hut opening criterion: s/d < theta
        let node_size = node.bounding_box.size()
        
        if node.is_leaf or (node_size / r) < self.theta:
            # Use this node as approximation
            let r_inv_cubed = 1.0 / (r_sq * r)
            let force_magnitude = params.G * target_mass * node.total_mass * r_inv_cubed
            
            return Vector3D(
                force_magnitude * dx,
                force_magnitude * dy,
                force_magnitude * dz
            )
        else:
            # Recursively compute force from children
            var total_force = Vector3D()
            
            for i in range(len(node.children)):
                let child_force = self._compute_force_recursive(node.children[i], target_pos, target_mass, params)
                total_force.x += child_force.x
                total_force.y += child_force.y
                total_force.z += child_force.z
            
            return total_force

struct ParticleMesh:
    """Particle-Mesh method for long-range force calculation"""
    var grid_size: Int
    var box_size: Float32
    var cell_size: Float32
    var density_grid: DynamicVector[DynamicVector[DynamicVector[Float32]]]
    var potential_grid: DynamicVector[DynamicVector[DynamicVector[Float32]]]
    
    fn __init__(inout self, grid_size: Int, box_size: Float32):
        self.grid_size = grid_size
        self.box_size = box_size
        self.cell_size = box_size / grid_size
        
        # Initialize 3D grids
        self.density_grid = DynamicVector[DynamicVector[DynamicVector[Float32]]]()
        self.potential_grid = DynamicVector[DynamicVector[DynamicVector[Float32]]]()
        
        for i in range(grid_size):
            var plane_density = DynamicVector[DynamicVector[Float32]]()
            var plane_potential = DynamicVector[DynamicVector[Float32]]()
            
            for j in range(grid_size):
                var row_density = DynamicVector[Float32]()
                var row_potential = DynamicVector[Float32]()
                
                for k in range(grid_size):
                    row_density.push_back(0.0)
                    row_potential.push_back(0.0)
                
                plane_density.push_back(row_density)
                plane_potential.push_back(row_potential)
            
            self.density_grid.push_back(plane_density)
            self.potential_grid.push_back(plane_potential)
    
    fn assign_particles_to_grid(inout self, particles: DynamicVector[Particle]):
        """Assign particle masses to grid using Cloud-in-Cell (CIC) scheme"""
        # Clear density grid
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                for k in range(self.grid_size):
                    self.density_grid[i][j][k] = 0.0
        
        # Assign particles using CIC interpolation
        for p in range(len(particles)):
            let particle = particles[p]
            
            # Convert position to grid coordinates
            let gx = particle.x.cast[DType.float32]() / self.cell_size
            let gy = particle.y.cast[DType.float32]() / self.cell_size
            let gz = particle.z.cast[DType.float32]() / self.cell_size
            
            # Get grid indices and fractional parts
            let i0 = int(gx) % self.grid_size
            let j0 = int(gy) % self.grid_size
            let k0 = int(gz) % self.grid_size
            
            let i1 = (i0 + 1) % self.grid_size
            let j1 = (j0 + 1) % self.grid_size
            let k1 = (k0 + 1) % self.grid_size
            
            let dx = gx - int(gx)
            let dy = gy - int(gy)
            let dz = gz - int(gz)
            
            let mass = particle.mass.cast[DType.float32]()
            
            # CIC weights
            let w000 = (1-dx) * (1-dy) * (1-dz)
            let w001 = (1-dx) * (1-dy) * dz
            let w010 = (1-dx) * dy * (1-dz)
            let w011 = (1-dx) * dy * dz
            let w100 = dx * (1-dy) * (1-dz)
            let w101 = dx * (1-dy) * dz
            let w110 = dx * dy * (1-dz)
            let w111 = dx * dy * dz
            
            # Distribute mass to 8 nearest grid points
            self.density_grid[i0][j0][k0] += mass * w000
            self.density_grid[i0][j0][k1] += mass * w001
            self.density_grid[i0][j1][k0] += mass * w010
            self.density_grid[i0][j1][k1] += mass * w011
            self.density_grid[i1][j0][k0] += mass * w100
            self.density_grid[i1][j0][k1] += mass * w101
            self.density_grid[i1][j1][k0] += mass * w110
            self.density_grid[i1][j1][k1] += mass * w111
    
    fn solve_poisson_fft(inout self, G: Float32):
        """Solve Poisson equation using FFT (simplified version)"""
        # This is a simplified placeholder for FFT-based Poisson solver
        # In practice, this would use 3D FFT to solve âÂ²Ï = 4ÏGÏ
        
        # Convert density to potential using Green's function
        for i in range(self.grid_size):
            for j in range(self.grid_size):
                for k in range(self.grid_size):
                    # Simple finite difference approximation
                    # In real implementation, this would be done in Fourier space
                    self.potential_grid[i][j][k] = -G * self.density_grid[i][j][k] * self.cell_size * self.cell_size
    
    fn compute_forces_from_potential(self, inout particles: DynamicVector[Particle]):
        """Compute forces on particles from grid potential using finite differences"""
        for p in range(len(particles)):
            let particle = particles[p]
            
            # Convert position to grid coordinates
            let gx = particle.x.cast[DType.float32]() / self.cell_size
            let gy = particle.y.cast[DType.float32]() / self.cell_size
            let gz = particle.z.cast[DType.float32]() / self.cell_size
            
            # Get grid indices
            let i = int(gx) % self.grid_size
            let j = int(gy) % self.grid_size
            let k = int(gz) % self.grid_size
            
            let ip = (i + 1) % self.grid_size
            let im = (i - 1 + self.grid_size) % self.grid_size
            let jp = (j + 1) % self.grid_size
            let jm = (j - 1 + self.grid_size) % self.grid_size
            let kp = (k + 1) % self.grid_size
            let km = (k - 1 + self.grid_size) % self.grid_size
            
            # Compute force using finite differences: F = -âÏ
            let fx = -(self.potential_grid[ip][j][k] - self.potential_grid[im][j][k]) / (2 * self.cell_size)
            let fy = -(self.potential_grid[i][jp][k] - self.potential_grid[i][jm][k]) / (2 * self.cell_size)
            let fz = -(self.potential_grid[i][j][kp] - self.potential_grid[i][j][km]) / (2 * self.cell_size)
            
            particles[p].fx += fx
            particles[p].fy += fy
            particles[p].fz += fz

struct TreePMSystem:
    """Hybrid TreePM system combining Barnes-Hut and Particle-Mesh methods"""
    var tree: BarnesHutTree
    var pm: ParticleMesh
    var split_scale: Float32  # Scale separating short/long range forces
    
    fn __init__(inout self, grid_size: Int, box_size: Float32, split_scale: Float32):
        self.tree = BarnesHutTree()
        self.pm = ParticleMesh(grid_size, box_size)
        self.split_scale = split_scale
    
    fn compute_forces(inout self, inout particles: DynamicVector[Particle], params: HACCParameters):
        """Compute forces using hybrid TreePM method"""
        
        # Reset all forces
        for i in range(len(particles)):
            particles[i].reset_forces()
        
        # Long-range forces via PM method
        self.pm.assign_particles_to_grid(particles)
        self.pm.solve_poisson_fft(params.G)
        self.pm.compute_forces_from_potential(particles)
        
        # Short-range forces via tree method
        self.tree.build_tree(particles)
        
        for i in range(len(particles)):
            let particle_pos = Vector3D(
                particles[i].x.cast[DType.float32](),
                particles[i].y.cast[DType.float32](),
                particles[i].z.cast[DType.float32]()
            )
            
            let tree_force = self.tree.compute_force_on_particle(
                particle_pos,
                particles[i].mass.cast[DType.float32](),
                params
            )
            
            # Add short-range correction (subtract long-range component already included in PM)
            # This requires careful implementation of force splitting
            particles[i].fx += tree_force.x * 0.5  # Simplified weighting
            particles[i].fy += tree_force.y * 0.5
            particles[i].fz += tree_force.z * 0.5

struct AdvancedHACCBenchmark:
    """Benchmark suite for advanced HACC methods"""
    var particles: DynamicVector[Particle]
    var tree_pm_system: TreePMSystem
    var n_particles: Int
    
    fn __init__(inout self, n_particles: Int, grid_size: Int = 64):
        self.n_particles = n_particles
        self.particles = DynamicVector[Particle](capacity=n_particles)
        
        # Initialize particles in a cosmological-like distribution
        self._initialize_cosmological_distribution()
        
        self.tree_pm_system = TreePMSystem(grid_size, 1.0, 0.1)
    
    fn _initialize_cosmological_distribution(inout self):
        """Initialize particles with cosmological-like clustering"""
        # Create a simple clustered distribution
        let n_clusters = max(1, self.n_particles // 50)
        
        for cluster in range(n_clusters):
            # Cluster center
            let cx = rand[FLOAT_TYPE]().cast[DType.float32]()
            let cy = rand[FLOAT_TYPE]().cast[DType.float32]()
            let cz = rand[FLOAT_TYPE]().cast[DType.float32]()
            
            let particles_per_cluster = self.n_particles // n_clusters
            let cluster_size = 0.1  # Cluster size
            
            for p in range(particles_per_cluster):
                # Random offset within cluster
                let dx = (rand[FLOAT_TYPE]().cast[DType.float32]() - 0.5) * cluster_size
                let dy = (rand[FLOAT_TYPE]().cast[DType.float32]() - 0.5) * cluster_size
                let dz = (rand[FLOAT_TYPE]().cast[DType.float32]() - 0.5) * cluster_size
                
                let particle = Particle(cx + dx, cy + dy, cz + dz, 1.0)
                self.particles.push_back(particle)
        
        # Fill remaining particles randomly
        let remaining = self.n_particles - len(self.particles)
        for i in range(remaining):
            let x = rand[FLOAT_TYPE]().cast[DType.float32]()
            let y = rand[FLOAT_TYPE]().cast[DType.float32]()
            let z = rand[FLOAT_TYPE]().cast[DType.float32]()
            self.particles.push_back(Particle(x, y, z, 1.0))
    
    fn benchmark_tree_method(inout self, iterations: Int = 5) -> Float64:
        """Benchmark Barnes-Hut tree method"""
        print("Benchmarking Barnes-Hut tree method...")
        
        var total_time: Float64 = 0.0
        let params = HACCParameters()
        
        for iter in range(iterations):
            let start_time = now()
            
            # Build tree and compute forces
            self.tree_pm_system.tree.build_tree(self.particles)
            
            for i in range(len(self.particles)):
                let particle_pos = Vector3D(
                    self.particles[i].x.cast[DType.float32](),
                    self.particles[i].y.cast[DType.float32](),
                    self.particles[i].z.cast[DType.float32]()
                )
                
                let force = self.tree_pm_system.tree.compute_force_on_particle(
                    particle_pos,
                    self.particles[i].mass.cast[DType.float32](),
                    params
                )
                
                self.particles[i].fx = force.x
                self.particles[i].fy = force.y
                self.particles[i].fz = force.z
            
            let end_time = now()
            let iteration_time = (end_time - start_time).cast[DType.float64]() / 1e9
            total_time += iteration_time
        
        let avg_time = total_time / iterations
        print("Tree method average time:", avg_time, "seconds")
        print("Tree method complexity: O(N log N) vs O(NÂ²) direct")
        
        return avg_time
    
    fn benchmark_pm_method(inout self, iterations: Int = 5) -> Float64:
        """Benchmark Particle-Mesh method"""
        print("Benchmarking Particle-Mesh method...")
        
        var total_time: Float64 = 0.0
        let params = HACCParameters()
        
        for iter in range(iterations):
            let start_time = now()
            
            # PM force calculation
            self.tree_pm_system.pm.assign_particles_to_grid(self.particles)
            self.tree_pm_system.pm.solve_poisson_fft(params.G)
            self.tree_pm_system.pm.compute_forces_from_potential(self.particles)
            
            let end_time = now()
            let iteration_time = (end_time - start_time).cast[DType.float64]() / 1e9
            total_time += iteration_time
        
        let avg_time = total_time / iterations
        print("PM method average time:", avg_time, "seconds")
        print("PM method complexity: O(N) + FFT overhead")
        
        return avg_time
    
    fn benchmark_tree_pm_hybrid(inout self, iterations: Int = 5) -> Float64:
        """Benchmark hybrid TreePM method"""
        print("Benchmarking TreePM hybrid method...")
        
        var total_time: Float64 = 0.0
        let params = HACCParameters()
        
        for iter in range(iterations):
            let start_time = now()
            
            self.tree_pm_system.compute_forces(self.particles, params)
            
            let end_time = now()
            let iteration_time = (end_time - start_time).cast[DType.float64]() / 1e9
            total_time += iteration_time
        
        let avg_time = total_time / iterations
        print("TreePM hybrid average time:", avg_time, "seconds")
        print("TreePM combines best of both methods")
        
        return avg_time
    
    fn run_advanced_benchmarks(inout self):
        """Run comprehensive advanced method benchmarks"""
        print("="*60)
        print("Advanced HACC Kernels - Tree and PM Methods")
        print("Particles:", self.n_particles)
        print("="*60)
        
        let tree_time = self.benchmark_tree_method()
        print()
        
        let pm_time = self.benchmark_pm_method()  
        print()
        
        let tree_pm_time = self.benchmark_tree_pm_hybrid()
        print()
        
        print("--- Method Comparison ---")
        print("Tree method time:", tree_time, "s")
        print("PM method time:", pm_time, "s") 
        print("TreePM method time:", tree_pm_time, "s")
        
        # Theoretical complexity analysis
        let n = Float64(self.n_particles)
        let n_squared_ops = n * n / 2
        let n_log_n_ops = n * log2(n)
        
        print("\nTheoretical operation counts:")
        print("Direct O(NÂ²):", n_squared_ops)
        print("Tree O(N log N):", n_log_n_ops)
        print("Speedup factor (theory):", n_squared_ops / n_log_n_ops)

fn main():
    """Main function for advanced benchmarks"""
    print("Advanced HACCKernels Benchmarks")
    
    let test_sizes = DynamicVector[Int]()
    test_sizes.push_back(1000)
    test_sizes.push_back(5000)
    test_sizes.push_back(10000)
    
    for i in range(len(test_sizes)):
        let n_particles = test_sizes[i]
        var benchmark = AdvancedHACCBenchmark(n_particles)
        benchmark.run_advanced_benchmarks()
        print("\n" + "="*60 + "\n")

if __name__ == "__main__":
    main()