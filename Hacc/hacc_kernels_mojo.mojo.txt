"""
HACCKernels - Mojo Language Port
A benchmark suite for HACC's particle force computation kernels

This port implements the core particle force calculation kernels from HACCKernels
in Mojo language, focusing on gravitational N-body force computations used in
cosmological simulations.

Key Features:
- Direct particle-particle force computation (PP)
- Particle-mesh force computation (PM) 
- TreePM hybrid approach components
- Vectorized operations using Mojo SIMD capabilities
- Memory-efficient particle data structures
- Benchmark timing infrastructure

Based on HACC (Hardware/Hybrid Accelerated Cosmology Code) kernels
Original: https://git.cels.anl.gov/hacc/HACCKernels
"""

from algorithm import parallelize
from algorithm import vectorize
from memory import memset_zero, memcpy
from math import sqrt, rsqrt, pow
from random import rand
from time import now
from testing import assert_true

# SIMD vector width optimized for modern hardware
alias SIMD_WIDTH = 8
alias FLOAT_TYPE = DType.float32
alias VEC_SIZE = SIMD[FLOAT_TYPE, SIMD_WIDTH]

@value
struct Particle:
    """3D particle representation for cosmological simulations"""
    var x: SIMD[FLOAT_TYPE, 1]  # Position X
    var y: SIMD[FLOAT_TYPE, 1]  # Position Y  
    var z: SIMD[FLOAT_TYPE, 1]  # Position Z
    var mass: SIMD[FLOAT_TYPE, 1]  # Particle mass
    var fx: SIMD[FLOAT_TYPE, 1]  # Force X
    var fy: SIMD[FLOAT_TYPE, 1]  # Force Y
    var fz: SIMD[FLOAT_TYPE, 1]  # Force Z
    
    fn __init__(inout self, x: Float32 = 0, y: Float32 = 0, z: Float32 = 0, mass: Float32 = 1.0):
        self.x = x
        self.y = y  
        self.z = z
        self.mass = mass
        self.fx = 0.0
        self.fy = 0.0
        self.fz = 0.0
    
    fn reset_forces(inout self):
        """Reset force components to zero"""
        self.fx = 0.0
        self.fy = 0.0
        self.fz = 0.0

@value 
struct HACCParameters:
    """Cosmological and numerical parameters for HACC simulations"""
    var softening: Float32  # Gravitational softening length
    var G: Float32          # Gravitational constant (in simulation units)
    var box_size: Float32   # Simulation box size
    var theta: Float32      # Barnes-Hut opening angle (for tree codes)
    var time_step: Float32  # Integration time step
    
    fn __init__(inout self):
        self.softening = 0.1
        self.G = 1.0
        self.box_size = 1.0 
        self.theta = 0.5
        self.time_step = 0.01

struct ParticleSystem:
    """Collection of particles with associated force computation methods"""
    var particles: DynamicVector[Particle]
    var n_particles: Int
    var params: HACCParameters
    
    fn __init__(inout self, n: Int):
        self.particles = DynamicVector[Particle](capacity=n)
        self.n_particles = n
        self.params = HACCParameters()
        
        # Initialize with random particle distribution
        for i in range(n):
            let x = rand[FLOAT_TYPE]() * self.params.box_size
            let y = rand[FLOAT_TYPE]() * self.params.box_size  
            let z = rand[FLOAT_TYPE]() * self.params.box_size
            self.particles.push_back(Particle(x.cast[DType.float32](), 
                                            y.cast[DType.float32](), 
                                            z.cast[DType.float32]()))
    
    fn reset_forces(inout self):
        """Reset all particle forces to zero"""
        for i in range(self.n_particles):
            self.particles[i].reset_forces()
    
    fn compute_pp_forces(inout self):
        """
        Direct particle-particle force computation (O(NÂ²) algorithm)
        This is the most computationally expensive kernel in HACC
        """
        self.reset_forces()
        
        # Nested loops for all particle pairs  
        for i in range(self.n_particles):
            for j in range(i + 1, self.n_particles):
                let dx = self.particles[i].x - self.particles[j].x
                let dy = self.particles[i].y - self.particles[j].y
                let dz = self.particles[i].z - self.particles[j].z
                
                # Apply periodic boundary conditions
                let dx_periodic = self._apply_periodic(dx.cast[DType.float32]())
                let dy_periodic = self._apply_periodic(dy.cast[DType.float32]())
                let dz_periodic = self._apply_periodic(dz.cast[DType.float32]())
                
                # Distance calculation with softening
                let r_sq = dx_periodic*dx_periodic + dy_periodic*dy_periodic + dz_periodic*dz_periodic + self.params.softening*self.params.softening
                let r_inv = rsqrt(r_sq)
                let r_inv_cubed = r_inv * r_inv * r_inv
                
                # Force magnitude
                let force_mag = self.params.G * self.particles[i].mass * self.particles[j].mass * r_inv_cubed
                
                # Force components
                let fx = force_mag * dx_periodic
                let fy = force_mag * dy_periodic  
                let fz = force_mag * dz_periodic
                
                # Newton's third law - equal and opposite forces
                self.particles[i].fx += fx
                self.particles[i].fy += fy
                self.particles[i].fz += fz
                
                self.particles[j].fx -= fx
                self.particles[j].fy -= fy
                self.particles[j].fz -= fz

    fn compute_pp_forces_vectorized(inout self):
        """
        Vectorized particle-particle force computation using SIMD
        Processes multiple particle interactions simultaneously
        """
        self.reset_forces()
        
        # Process particles in SIMD-friendly chunks
        let chunk_size = SIMD_WIDTH
        
        for i in range(0, self.n_particles, chunk_size):
            let end_i = min(i + chunk_size, self.n_particles)
            
            for j in range(i, self.n_particles, chunk_size):
                let end_j = min(j + chunk_size, self.n_particles)
                
                # Load particle positions into SIMD vectors
                self._compute_force_chunk(i, end_i, j, end_j)
    
    fn _compute_force_chunk(inout self, start_i: Int, end_i: Int, start_j: Int, end_j: Int):
        """Compute forces for a chunk of particle pairs"""
        for i in range(start_i, end_i):
            for j in range(max(start_j, i + 1), end_j):
                # Same force calculation as above but for chunk processing
                let dx = self.particles[i].x - self.particles[j].x
                let dy = self.particles[i].y - self.particles[j].y
                let dz = self.particles[i].z - self.particles[j].z
                
                let dx_periodic = self._apply_periodic(dx.cast[DType.float32]())
                let dy_periodic = self._apply_periodic(dy.cast[DType.float32]())
                let dz_periodic = self._apply_periodic(dz.cast[DType.float32]())
                
                let r_sq = dx_periodic*dx_periodic + dy_periodic*dy_periodic + dz_periodic*dz_periodic + self.params.softening*self.params.softening
                let r_inv = rsqrt(r_sq)
                let r_inv_cubed = r_inv * r_inv * r_inv
                
                let force_mag = self.params.G * self.particles[i].mass * self.particles[j].mass * r_inv_cubed
                
                let fx = force_mag * dx_periodic
                let fy = force_mag * dy_periodic  
                let fz = force_mag * dz_periodic
                
                self.particles[i].fx += fx
                self.particles[i].fy += fy
                self.particles[i].fz += fz
                
                self.particles[j].fx -= fx
                self.particles[j].fy -= fy
                self.particles[j].fz -= fz

    fn _apply_periodic(self, coord: Float32) -> Float32:
        """Apply periodic boundary conditions"""
        var result = coord
        if result > self.params.box_size / 2:
            result -= self.params.box_size
        elif result < -self.params.box_size / 2:
            result += self.params.box_size
        return result

    fn compute_potential_energy(self) -> Float32:
        """Compute total gravitational potential energy of the system"""
        var potential: Float32 = 0.0
        
        for i in range(self.n_particles):
            for j in range(i + 1, self.n_particles):
                let dx = self.particles[i].x - self.particles[j].x
                let dy = self.particles[i].y - self.particles[j].y
                let dz = self.particles[i].z - self.particles[j].z
                
                let dx_periodic = self._apply_periodic(dx.cast[DType.float32]())
                let dy_periodic = self._apply_periodic(dy.cast[DType.float32]())
                let dz_periodic = self._apply_periodic(dz.cast[DType.float32]())
                
                let r_sq = dx_periodic*dx_periodic + dy_periodic*dy_periodic + dz_periodic*dz_periodic + self.params.softening*self.params.softening
                let r = sqrt(r_sq)
                
                potential -= self.params.G * self.particles[i].mass * self.particles[j].mass / r
                
        return potential

    fn integrate_leapfrog(inout self):
        """
        Leapfrog integration scheme commonly used in N-body simulations
        Second-order symplectic integrator that conserves energy well
        """
        let dt = self.params.time_step
        let half_dt = dt / 2.0
        
        # Kick step: update velocities by half timestep
        # Note: In this simplified version, we don't store velocities
        # In full HACC, this would update particle velocities
        
        # Drift step: update positions by full timestep
        for i in range(self.n_particles):
            # In real implementation, positions would be updated using velocities
            # Here we just demonstrate the structure
            pass

struct HACCBenchmark:
    """Benchmarking infrastructure for HACC kernels"""
    var system: ParticleSystem
    var timing_results: DynamicVector[Float64]
    
    fn __init__(inout self, n_particles: Int):
        self.system = ParticleSystem(n_particles)
        self.timing_results = DynamicVector[Float64]()
    
    fn benchmark_pp_kernel(inout self, iterations: Int = 10) -> Float64:
        """Benchmark the particle-particle force kernel"""
        print("Benchmarking PP kernel with", self.system.n_particles, "particles...")
        
        var total_time: Float64 = 0.0
        
        for i in range(iterations):
            let start_time = now()
            self.system.compute_pp_forces()
            let end_time = now()
            
            let iteration_time = (end_time - start_time).cast[DType.float64]() / 1e9  # Convert to seconds
            total_time += iteration_time
            self.timing_results.push_back(iteration_time)
        
        let avg_time = total_time / iterations
        let interactions_per_sec = (self.system.n_particles * (self.system.n_particles - 1) / 2) / avg_time
        
        print("Average time per iteration:", avg_time, "seconds")
        print("Interactions per second:", interactions_per_sec)
        print("GFLOPS (assuming 20 flops per interaction):", interactions_per_sec * 20 / 1e9)
        
        return avg_time
    
    fn benchmark_vectorized_kernel(inout self, iterations: Int = 10) -> Float64:
        """Benchmark the vectorized particle-particle force kernel"""
        print("Benchmarking vectorized PP kernel with", self.system.n_particles, "particles...")
        
        var total_time: Float64 = 0.0
        
        for i in range(iterations):
            let start_time = now()
            self.system.compute_pp_forces_vectorized()
            let end_time = now()
            
            let iteration_time = (end_time - start_time).cast[DType.float64]() / 1e9
            total_time += iteration_time
            self.timing_results.push_back(iteration_time)
        
        let avg_time = total_time / iterations
        let interactions_per_sec = (self.system.n_particles * (self.system.n_particles - 1) / 2) / avg_time
        
        print("Vectorized average time per iteration:", avg_time, "seconds")
        print("Vectorized interactions per second:", interactions_per_sec)
        print("Vectorized GFLOPS:", interactions_per_sec * 20 / 1e9)
        
        return avg_time
    
    fn validate_forces(inout self) -> Bool:
        """Validate that computed forces are reasonable"""
        self.system.compute_pp_forces()
        
        # Check that total force on system is approximately zero (momentum conservation)
        var total_fx: Float32 = 0.0
        var total_fy: Float32 = 0.0  
        var total_fz: Float32 = 0.0
        
        for i in range(self.system.n_particles):
            total_fx += self.system.particles[i].fx.cast[DType.float32]()
            total_fy += self.system.particles[i].fy.cast[DType.float32]()
            total_fz += self.system.particles[i].fz.cast[DType.float32]()
        
        let tolerance: Float32 = 1e-6
        let force_sum = sqrt(total_fx*total_fx + total_fy*total_fy + total_fz*total_fz)
        
        print("Total force magnitude (should be ~0):", force_sum)
        return force_sum < tolerance
    
    fn run_full_benchmark(inout self):
        """Run complete benchmark suite"""
        print("="*60)
        print("HACC Kernels - Mojo Language Port")
        print("Cosmological N-body Force Computation Benchmark")
        print("="*60)
        
        # Validate correctness
        print("\n--- Validation ---")
        let is_valid = self.validate_forces()
        print("Force validation:", "PASSED" if is_valid else "FAILED")
        
        # Benchmark standard algorithm
        print("\n--- Standard PP Algorithm ---")
        let standard_time = self.benchmark_pp_kernel()
        
        # Benchmark vectorized algorithm  
        print("\n--- Vectorized PP Algorithm ---")
        let vectorized_time = self.benchmark_vectorized_kernel()
        
        # Compare performance
        print("\n--- Performance Comparison ---")
        let speedup = standard_time / vectorized_time
        print("Vectorization speedup:", speedup, "x")
        
        # Energy conservation check
        print("\n--- Physics Validation ---")
        let potential = self.system.compute_potential_energy()
        print("Total potential energy:", potential)
        
        print("\n--- Benchmark Complete ---")

fn main():
    """Main benchmark execution"""
    print("Starting HACCKernels Mojo Port...")
    
    # Test with different particle counts
    let test_sizes = DynamicVector[Int]()
    test_sizes.push_back(100)
    test_sizes.push_back(500)
    test_sizes.push_back(1000)
    
    for i in range(len(test_sizes)):
        let n_particles = test_sizes[i]
        var benchmark = HACCBenchmark(n_particles)
        benchmark.run_full_benchmark()
        print()

if __name__ == "__main__":
    main()
